**** New definitions: R, type: {A:r8, B:s}
**** New definitions: T, type: {A:r8, B:s}*

> module { var X from T; let Num := X->Count() }
module { var X from T; let Num := X->Count() } : M{let Num:i8, var X:{A:r8, B:s}*}
BndKind:Module, Type:M{let Num:i8, var X:{A:r8, B:s}*}, Bnd:(module[ext[with:1] (Global(T),), items[with:2] ]{ var X from GetSlot(Scope(1), 0) def GetSlot(Scope(2), 0) opt; let Num := Call(∂.Count(GetSlot(Scope(2), 1)):i8) })
// (<ctx>, ∂.T:{A:r8, B:s}*) : M{let Num:i8, var X:{A:r8, B:s}*}
set_module_items_ext(Arr<obj>, Arr<bool>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), {i8,Seq<{r8,str}>}, (Seq<{r8,str}>)):(Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.0
      1) ldelem.u1
      5) brtrue [0]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      2) ldarg.s [(Seq<{r8,str}>) (4)]
      5) ldfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:Seq<{r8,str}>
  Label [0]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.3
      1) ldelem.u1
      5) brfalse [1]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.3 [{i8,Seq<{r8,str}>}]
      5) ldfld {i8,Seq<{r8,str}>}::_F1:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
      5) br [2]
  Label [1]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.1
      1) ldelem.u1
      5) brtrue [2]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
  Label [2]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.2
      1) ldelem.u1
      5) brtrue [3]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.0
      5) call static CountGen::Exec(Seq<{r8,str}>, ExecCtx, i4):i8
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:i8
  Label [3]:
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ret
  Total Size: 101

make_module_record(Arr<obj>, (Seq<{r8,str}>,Seq<{r8,str}>,i8)):{i8,Seq<{r8,str}>}
      5) newobj {i8,Seq<{r8,str}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {i8,Seq<{r8,str}>}::_B0:u1
      1) stloc.0 [{i8,Seq<{r8,str}>}]
      1) ldloc.0 [{i8,Seq<{r8,str}>}]
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
      5) stfld {i8,Seq<{r8,str}>}::_F1:Seq<{r8,str}>
      1) ldloc.0 [{i8,Seq<{r8,str}>}]
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:i8
      5) stfld {i8,Seq<{r8,str}>}::_F0:i8
      1) ldloc.0 [{i8,Seq<{r8,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

set_module_value_item(Arr<obj>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), i4, obj):(Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.2 [i4]
     17) switch [0,1,0]
      5) br [0]
  Label [1]:
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.3 [obj]
      5) unbox.any [Seq<{r8,str}>]
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
  Label [0]:
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ret
  Total Size: 37

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{r8,str}>
      1) stloc.1 [Seq<{r8,str}>]
      5) newobj (Seq<{r8,str}>)()
      1) stloc.2 [(Seq<{r8,str}>)]
      1) ldloc.2 [(Seq<{r8,str}>)]
      1) ldloc.1 [Seq<{r8,str}>]
      5) stfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<Arr<bool>,(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>},(Seq<{r8,str}>),(Seq<{r8,str}>,Seq<{r8,str}>,i8)>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.2
      5) newarr [obj]
      1) dup
      1) ldc.i4.1
      1) ldloc.0 [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      1) dup
      1) ldc.i4.5
      5) newarr [bool]
      5) newobj (Seq<{r8,str}>,Seq<{r8,str}>,i8)()
      1) ldnull
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) callvirt Func<Arr<bool>,(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>},(Seq<{r8,str}>),(Seq<{r8,str}>,Seq<{r8,str}>,i8)>::Invoke(Arr<bool>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), {i8,Seq<{r8,str}>}, (Seq<{r8,str}>)):(Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),i4,obj,(Seq<{r8,str}>,Seq<{r8,str}>,i8)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [BndModuleNode]
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) newobj RuntimeModule<{i8,Seq<{r8,str}>},(Seq<{r8,str}>,Seq<{r8,str}>,i8),(Seq<{r8,str}>)>(Func<Arr<bool>,(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>},(Seq<{r8,str}>),(Seq<{r8,str}>,Seq<{r8,str}>,i8)>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>}>, Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),i4,obj,(Seq<{r8,str}>,Seq<{r8,str}>,i8)>, BndModuleNode, (Seq<{r8,str}>))
      1) ret
  Total Size: 114

Func sig: (<ctx>:x, T:{A:r8, B:s}*) to M{let Num:i8, var X:{A:r8, B:s}*}
Type: RuntimeModule<{i8,Seq<{r8,str}>},(Seq<{r8,str}>,Seq<{r8,str}>,i8),(Seq<{r8,str}>)>, Value: module symbols:
  var X from Sequence: Seq<{r8,str}>
     0) { A: 0, B: 0 }
     1) { A: 0.5, B: 1 }
     2) { A: 1, B: 2 }
     3) { A: 1.5, B: 3 }
     4) { A: 2, B: 4 }
     5) { A: 2.5, B: 5 }
     6) { A: 3, B: 6 }
     7) { A: 3.5, B: 7 }
     8) { A: 4, B: 8 }
     9) { A: 4.5, B: 9 }
     def Sequence: Seq<{r8,str}>
     0) { A: 0, B: 0 }
     1) { A: 0.5, B: 1 }
     2) { A: 1, B: 2 }
     3) { A: 1.5, B: 3 }
     4) { A: 2, B: 4 }
     5) { A: 2.5, B: 5 }
     6) { A: 3, B: 6 }
     7) { A: 3.5, B: 7 }
     8) { A: 4, B: 8 }
     9) { A: 4.5, B: 9 }
  let Num: 10
*** Ctx ping count: 0
###
> With(
    M : module {
        param N := 2;
        var X from T->Take(N);
        let Num := X->Count();
    },
    (M, M with { N : 5 }))
With(M : module { param N := 2; var X from T->Take(N); let Num := X->Count() }, (M, M=>{ N : 5 })) : (M{param N:i8, let Num:i8, var X:{A:r8, B:s}*}, M{param N:i8, let Num:i8, var X:{A:r8, B:s}*})
BndKind:Call, Type:(M{param N:i8, let Num:i8, var X:{A:r8, B:s}*}, M{param N:i8, let Num:i8, var X:{A:r8, B:s}*}), Bnd:(Call(∂.With([with:3] module[ext[with:1] (Global(T),), items[with:2] ]{ param N := 2:i8; var X from Call(∂.Take(GetSlot(Scope(1), 0), GetSlot(Scope(2), 0))) def GetSlot(Scope(2), 1) opt; let Num := Call(∂.Count(GetSlot(Scope(2), 2)):i8) }, (Scope(3), ModuleProjection([with:4] Scope(3), {N:5:i8})):(M{param N:i8, let Num:i8, var X:{A:r8, B:s}*}, M{param N:i8, let Num:i8, var X:{A:r8, B:s}*})):(M{param N:i8, let Num:i8, var X:{A:r8, B:s}*}, M{param N:i8, let Num:i8, var X:{A:r8, B:s}*})))
// (<ctx>, ∂.T:{A:r8, B:s}*) : (M{param N:i8, let Num:i8, var X:{A:r8, B:s}*}, M{param N:i8, let Num:i8, var X:{A:r8, B:s}*})
set_module_items_ext(Arr<obj>, Arr<bool>, (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8), {i8,i8,Seq<{r8,str}>}, (Seq<{r8,str}>)):(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.4
      1) ldelem.u1
      5) brfalse [0]
      1) ldarg.2 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.3 [{i8,i8,Seq<{r8,str}>}]
      5) ldfld {i8,i8,Seq<{r8,str}>}::_F0:i8
      5) stfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:i8
      5) br [1]
  Label [0]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.0
      1) ldelem.u1
      5) brtrue [1]
      1) ldarg.2 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldc.i4.2
      1) conv.i8
      5) stfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:i8
  Label [1]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.1
      1) ldelem.u1
      5) brtrue [2]
      1) ldarg.2 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      2) ldarg.s [(Seq<{r8,str}>) (4)]
      5) ldfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      1) ldarg.2 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:i8
      5) call static TakeDropGen::ExecTakeNum(Seq<{r8,str}>, i8):Seq<{r8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{r8,str}>):Seq<{r8,str}>
      5) stfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
  Label [2]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.5
      1) ldelem.u1
      5) brfalse [3]
      1) ldarg.2 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.3 [{i8,i8,Seq<{r8,str}>}]
      5) ldfld {i8,i8,Seq<{r8,str}>}::_F2:Seq<{r8,str}>
      5) stfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:Seq<{r8,str}>
      5) br [4]
  Label [3]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.2
      1) ldelem.u1
      5) brtrue [4]
      1) ldarg.2 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.2 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
      5) stfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:Seq<{r8,str}>
  Label [4]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.3
      1) ldelem.u1
      5) brtrue [5]
      1) ldarg.2 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.2 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.0
      5) call static CountGen::Exec(Seq<{r8,str}>, ExecCtx, i4):i8
      5) stfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F3:i8
  Label [5]:
      1) ldarg.2 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ret
  Total Size: 158

make_module_record(Arr<obj>, (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)):{i8,i8,Seq<{r8,str}>}
      5) newobj {i8,i8,Seq<{r8,str}>}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,i8,Seq<{r8,str}>}::_B0:u1
      1) stloc.0 [{i8,i8,Seq<{r8,str}>}]
      1) ldloc.0 [{i8,i8,Seq<{r8,str}>}]
      1) ldarg.1 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:i8
      5) stfld {i8,i8,Seq<{r8,str}>}::_F0:i8
      1) ldloc.0 [{i8,i8,Seq<{r8,str}>}]
      1) ldarg.1 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:Seq<{r8,str}>
      5) stfld {i8,i8,Seq<{r8,str}>}::_F2:Seq<{r8,str}>
      1) ldloc.0 [{i8,i8,Seq<{r8,str}>}]
      1) ldarg.1 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F3:i8
      5) stfld {i8,i8,Seq<{r8,str}>}::_F1:i8
      1) ldloc.0 [{i8,i8,Seq<{r8,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

set_module_value_item(Arr<obj>, (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8), i4, obj):(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.2 [i4]
     21) switch [1,0,2,0]
      5) br [0]
  Label [1]:
      1) ldarg.1 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.3 [obj]
      5) unbox.any [i8]
      5) stfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:i8
      5) br [0]
  Label [2]:
      1) ldarg.1 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.3 [obj]
      5) unbox.any [Seq<{r8,str}>]
      5) stfld (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:Seq<{r8,str}>
  Label [0]:
      1) ldarg.1 [(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ret
  Total Size: 58

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{r8,str}>
      1) stloc.1 [Seq<{r8,str}>]
      5) newobj (Seq<{r8,str}>)()
      1) stloc.2 [(Seq<{r8,str}>)]
      1) ldloc.2 [(Seq<{r8,str}>)]
      1) ldloc.1 [Seq<{r8,str}>]
      5) stfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<Arr<bool>,(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,i8,Seq<{r8,str}>},(Seq<{r8,str}>),(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.2
      5) newarr [obj]
      1) dup
      1) ldc.i4.1
      1) ldloc.0 [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      1) dup
      1) ldc.i4.7
      5) newarr [bool]
      5) newobj (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)()
      1) ldnull
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) callvirt Func<Arr<bool>,(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,i8,Seq<{r8,str}>},(Seq<{r8,str}>),(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)>::Invoke(Arr<bool>, (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8), {i8,i8,Seq<{r8,str}>}, (Seq<{r8,str}>)):(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,i8,Seq<{r8,str}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8),i4,obj,(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [BndModuleNode]
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) newobj RuntimeModule<{i8,i8,Seq<{r8,str}>},(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8),(Seq<{r8,str}>)>(Func<Arr<bool>,(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,i8,Seq<{r8,str}>},(Seq<{r8,str}>),(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)>, (i8,Seq<{r8,str}>,Seq<{r8,str}>,i8), Func<(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,i8,Seq<{r8,str}>}>, Func<(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8),i4,obj,(i8,Seq<{r8,str}>,Seq<{r8,str}>,i8)>, BndModuleNode, (Seq<{r8,str}>))
      1) stloc.3 [RuntimeModule<{i8,i8,Seq<{r8,str}>}>]
      5) newobj (RuntimeModule<{i8,i8,Seq<{r8,str}>}>,RuntimeModule<{i8,i8,Seq<{r8,str}>}>)()
      1) dup
      1) ldloc.3 [RuntimeModule<{i8,i8,Seq<{r8,str}>}>]
      5) stfld (RuntimeModule<{i8,i8,Seq<{r8,str}>}>,RuntimeModule<{i8,i8,Seq<{r8,str}>}>)::_F0:RuntimeModule<{i8,i8,Seq<{r8,str}>}>
      1) dup
      1) ldloc.3 [RuntimeModule<{i8,i8,Seq<{r8,str}>}>]
      5) newobj {i8,i8,Seq<{r8,str}>}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,i8,Seq<{r8,str}>}::_B0:u1
      2) stloc.s [{i8,i8,Seq<{r8,str}>} (4)]
      2) ldloc.s [{i8,i8,Seq<{r8,str}>} (4)]
      1) ldc.i4.5
      1) conv.i8
      5) stfld {i8,i8,Seq<{r8,str}>}::_F0:i8
      2) ldloc.s [{i8,i8,Seq<{r8,str}>} (4)]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.4
      5) ldelem [HashSet<DName>]
      5) callvirt RuntimeModule<{i8,i8,Seq<{r8,str}>}>::Update({i8,i8,Seq<{r8,str}>}, HashSet<DName>):RuntimeModule<{i8,i8,Seq<{r8,str}>}>
      5) stfld (RuntimeModule<{i8,i8,Seq<{r8,str}>}>,RuntimeModule<{i8,i8,Seq<{r8,str}>}>)::_F1:RuntimeModule<{i8,i8,Seq<{r8,str}>}>
      1) ret
  Total Size: 171

Func sig: (<ctx>:x, T:{A:r8, B:s}*) to (M{param N:i8, let Num:i8, var X:{A:r8, B:s}*}, M{param N:i8, let Num:i8, var X:{A:r8, B:s}*})
Type: (RuntimeModule<{i8,i8,Seq<{r8,str}>}>,RuntimeModule<{i8,i8,Seq<{r8,str}>}>), Value: (module symbols:
      param N: 2
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
      let Num: 2
  , module symbols:
      param N: 5
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
      let Num: 5
)
*** Ctx ping count: 0
###
> Range(10)->ForEach(as n,
    module {
        var X from Range(n);
        let Num := X->Count()
    })
Range(10)->ForEach(as n, module { var X from Range(n); let Num := X->Count() }) : M{let Num:i8, var X:i8*}*
BndKind:Call, Type:M{let Num:i8, var X:i8*}*, Bnd:(Call(∂.ForEach([map:1] Call(∂.Range(10:i8):i8*), module[ext[with:2] (Scope(1),), items[with:3] ]{ var X from Call(∂.Range(GetSlot(Scope(2), 0)):i8*) def GetSlot(Scope(3), 0) opt; let Num := Call(∂.Count(GetSlot(Scope(3), 1)):i8) }):M{let Num:i8, var X:i8*}*))
// (<ctx>) : M{let Num:i8, var X:i8*}*
set_module_items_ext(Arr<obj>, Arr<bool>, (Seq<i8>,Seq<i8>,i8), {i8,Seq<i8>}, (i8)):(Seq<i8>,Seq<i8>,i8)
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.0
      1) ldelem.u1
      5) brtrue [0]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      2) ldarg.s [(i8) (4)]
      5) ldfld (i8)::_F0:i8
      5) call static RangeGen::Exec(i8):ICachingEnumerable<i8>
      5) stfld (Seq<i8>,Seq<i8>,i8)::_F0:Seq<i8>
  Label [0]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.3
      1) ldelem.u1
      5) brfalse [1]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      1) ldarg.3 [{i8,Seq<i8>}]
      5) ldfld {i8,Seq<i8>}::_F1:Seq<i8>
      5) stfld (Seq<i8>,Seq<i8>,i8)::_F1:Seq<i8>
      5) br [2]
  Label [1]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.1
      1) ldelem.u1
      5) brtrue [2]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      5) ldfld (Seq<i8>,Seq<i8>,i8)::_F0:Seq<i8>
      5) stfld (Seq<i8>,Seq<i8>,i8)::_F1:Seq<i8>
  Label [2]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.2
      1) ldelem.u1
      5) brtrue [3]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      5) ldfld (Seq<i8>,Seq<i8>,i8)::_F1:Seq<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.0
      5) call static CountGen::Exec(Seq<i8>, ExecCtx, i4):i8
      5) stfld (Seq<i8>,Seq<i8>,i8)::_F2:i8
  Label [3]:
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      1) ret
  Total Size: 106

make_module_record(Arr<obj>, (Seq<i8>,Seq<i8>,i8)):{i8,Seq<i8>}
      5) newobj {i8,Seq<i8>}()
      1) dup
      1) ldc.i4.1
      5) stfld {i8,Seq<i8>}::_B0:u1
      1) stloc.0 [{i8,Seq<i8>}]
      1) ldloc.0 [{i8,Seq<i8>}]
      1) ldarg.1 [(Seq<i8>,Seq<i8>,i8)]
      5) ldfld (Seq<i8>,Seq<i8>,i8)::_F1:Seq<i8>
      5) stfld {i8,Seq<i8>}::_F1:Seq<i8>
      1) ldloc.0 [{i8,Seq<i8>}]
      1) ldarg.1 [(Seq<i8>,Seq<i8>,i8)]
      5) ldfld (Seq<i8>,Seq<i8>,i8)::_F2:i8
      5) stfld {i8,Seq<i8>}::_F0:i8
      1) ldloc.0 [{i8,Seq<i8>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

set_module_value_item(Arr<obj>, (Seq<i8>,Seq<i8>,i8), i4, obj):(Seq<i8>,Seq<i8>,i8)
      1) ldarg.2 [i4]
     17) switch [0,1,0]
      5) br [0]
  Label [1]:
      1) ldarg.1 [(Seq<i8>,Seq<i8>,i8)]
      1) ldarg.3 [obj]
      5) unbox.any [Seq<i8>]
      5) stfld (Seq<i8>,Seq<i8>,i8)::_F1:Seq<i8>
  Label [0]:
      1) ldarg.1 [(Seq<i8>,Seq<i8>,i8)]
      1) ret
  Total Size: 37

ForEach_1(Arr<obj>, i8):RuntimeModule<{i8,Seq<i8>}>
      5) newobj (i8)()
      1) stloc.0 [(i8)]
      1) ldloc.0 [(i8)]
      1) ldarg.1 [i8]
      5) stfld (i8)::_F0:i8
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<Arr<bool>,(Seq<i8>,Seq<i8>,i8),{i8,Seq<i8>},(i8),(Seq<i8>,Seq<i8>,i8)>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.2
      5) newarr [obj]
      1) dup
      1) ldc.i4.1
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      1) dup
      1) ldc.i4.5
      5) newarr [bool]
      5) newobj (Seq<i8>,Seq<i8>,i8)()
      1) ldnull
      1) ldloc.0 [(i8)]
      5) callvirt Func<Arr<bool>,(Seq<i8>,Seq<i8>,i8),{i8,Seq<i8>},(i8),(Seq<i8>,Seq<i8>,i8)>::Invoke(Arr<bool>, (Seq<i8>,Seq<i8>,i8), {i8,Seq<i8>}, (i8)):(Seq<i8>,Seq<i8>,i8)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<(Seq<i8>,Seq<i8>,i8),{i8,Seq<i8>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<(Seq<i8>,Seq<i8>,i8),i4,obj,(Seq<i8>,Seq<i8>,i8)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [BndModuleNode]
      1) ldloc.0 [(i8)]
      5) newobj RuntimeModule<{i8,Seq<i8>},(Seq<i8>,Seq<i8>,i8),(i8)>(Func<Arr<bool>,(Seq<i8>,Seq<i8>,i8),{i8,Seq<i8>},(i8),(Seq<i8>,Seq<i8>,i8)>, (Seq<i8>,Seq<i8>,i8), Func<(Seq<i8>,Seq<i8>,i8),{i8,Seq<i8>}>, Func<(Seq<i8>,Seq<i8>,i8),i4,obj,(Seq<i8>,Seq<i8>,i8)>, BndModuleNode, (i8))
      1) ret
  Total Size: 126

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      2) ldc.i4.s [10]
      1) conv.i8
      5) call static RangeGen::Exec(i8):ICachingEnumerable<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<i8,RuntimeModule<{i8,Seq<i8>}>>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.2
      5) newarr [obj]
      1) dup
      1) ldc.i4.0
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Arr<obj>]
      5) stelem [Arr<obj>]
      1) dup
      1) ldc.i4.1
      1) ldloc.0 [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,RuntimeModule<{i8,Seq<i8>}>>):Seq<RuntimeModule<{i8,Seq<i8>}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<RuntimeModule<{i8,Seq<i8>}>>):Seq<RuntimeModule<{i8,Seq<i8>}>>
      1) ret
  Total Size: 78

Func sig: (<ctx>:x) to M{let Num:i8, var X:i8*}*
Sequence: Seq<RuntimeModule<{i8,Seq<i8>}>>
 0) module symbols:
      var X from Sequence: Seq<i8>
         def Sequence: Seq<i8>
      let Num: 0
 1) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         def Sequence: Seq<i8>
         0) 0
      let Num: 1
 2) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         def Sequence: Seq<i8>
         0) 0
         1) 1
      let Num: 2
 3) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
      let Num: 3
 4) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
      let Num: 4
 5) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
      let Num: 5
 6) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
      let Num: 6
 7) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
      let Num: 7
 8) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
         7) 7
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
         7) 7
      let Num: 8
 9) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
         7) 7
         8) 8
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
         7) 7
         8) 8
      let Num: 9
*** Ctx ping count: 0
###
> Range(10)->{ A: it, B: ToText(it) }->ForEach(
    module {
        var X from Range(A);
        let Num := X->Count()
    })
Range(10)->{ A : it, B : ToText(it) }->ForEach(module { var X from Range(A); let Num := X->Count() }) : M{let Num:i8, var X:i8*}*
BndKind:Call, Type:M{let Num:i8, var X:i8*}*, Bnd:(Call(∂.ForEach([map:1] Call(∂.Range(10:i8):i8*), module[ext[with:2] ({A:Scope(1), B:Call(∂.ToText(Scope(1)):s)},), items[with:3] ]{ var X from Call(∂.Range(GetField(GetSlot(Scope(2), 0), A)):i8*) def GetSlot(Scope(3), 0) opt; let Num := Call(∂.Count(GetSlot(Scope(3), 1)):i8) }):M{let Num:i8, var X:i8*}*))
// (<ctx>) : M{let Num:i8, var X:i8*}*
set_module_items_ext(Arr<obj>, Arr<bool>, (Seq<i8>,Seq<i8>,i8), {i8,Seq<i8>}, ({i8,str})):(Seq<i8>,Seq<i8>,i8)
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.0
      1) ldelem.u1
      5) brtrue [0]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      2) ldarg.s [({i8,str}) (4)]
      5) ldfld ({i8,str})::_F0:{i8,str}
      5) ldfld {i8,str}::_F0:i8
      5) call static RangeGen::Exec(i8):ICachingEnumerable<i8>
      5) stfld (Seq<i8>,Seq<i8>,i8)::_F0:Seq<i8>
  Label [0]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.3
      1) ldelem.u1
      5) brfalse [1]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      1) ldarg.3 [{i8,Seq<i8>}]
      5) ldfld {i8,Seq<i8>}::_F1:Seq<i8>
      5) stfld (Seq<i8>,Seq<i8>,i8)::_F1:Seq<i8>
      5) br [2]
  Label [1]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.1
      1) ldelem.u1
      5) brtrue [2]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      5) ldfld (Seq<i8>,Seq<i8>,i8)::_F0:Seq<i8>
      5) stfld (Seq<i8>,Seq<i8>,i8)::_F1:Seq<i8>
  Label [2]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.2
      1) ldelem.u1
      5) brtrue [3]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      5) ldfld (Seq<i8>,Seq<i8>,i8)::_F1:Seq<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.0
      5) call static CountGen::Exec(Seq<i8>, ExecCtx, i4):i8
      5) stfld (Seq<i8>,Seq<i8>,i8)::_F2:i8
  Label [3]:
      1) ldarg.2 [(Seq<i8>,Seq<i8>,i8)]
      1) ret
  Total Size: 111

make_module_record(Arr<obj>, (Seq<i8>,Seq<i8>,i8)):{i8,Seq<i8>}
      5) newobj {i8,Seq<i8>}()
      1) dup
      1) ldc.i4.1
      5) stfld {i8,Seq<i8>}::_B0:u1
      1) stloc.0 [{i8,Seq<i8>}]
      1) ldloc.0 [{i8,Seq<i8>}]
      1) ldarg.1 [(Seq<i8>,Seq<i8>,i8)]
      5) ldfld (Seq<i8>,Seq<i8>,i8)::_F1:Seq<i8>
      5) stfld {i8,Seq<i8>}::_F1:Seq<i8>
      1) ldloc.0 [{i8,Seq<i8>}]
      1) ldarg.1 [(Seq<i8>,Seq<i8>,i8)]
      5) ldfld (Seq<i8>,Seq<i8>,i8)::_F2:i8
      5) stfld {i8,Seq<i8>}::_F0:i8
      1) ldloc.0 [{i8,Seq<i8>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

set_module_value_item(Arr<obj>, (Seq<i8>,Seq<i8>,i8), i4, obj):(Seq<i8>,Seq<i8>,i8)
      1) ldarg.2 [i4]
     17) switch [0,1,0]
      5) br [0]
  Label [1]:
      1) ldarg.1 [(Seq<i8>,Seq<i8>,i8)]
      1) ldarg.3 [obj]
      5) unbox.any [Seq<i8>]
      5) stfld (Seq<i8>,Seq<i8>,i8)::_F1:Seq<i8>
  Label [0]:
      1) ldarg.1 [(Seq<i8>,Seq<i8>,i8)]
      1) ret
  Total Size: 37

ForEach_1(Arr<obj>, i8):RuntimeModule<{i8,Seq<i8>}>
      5) newobj ({i8,str})()
      1) stloc.0 [({i8,str})]
      1) ldloc.0 [({i8,str})]
      5) newobj {i8,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,str}::_B0:u1
      1) stloc.1 [{i8,str}]
      1) ldloc.1 [{i8,str}]
      1) ldarg.1 [i8]
      5) stfld {i8,str}::_F0:i8
      1) ldloc.1 [{i8,str}]
      1) ldarg.1 [i8]
      1) stloc.2 [i8]
      2) ldloca.s [i8 (2)]
      5) call i8::ToString():str
      5) stfld {i8,str}::_F1:str
      1) ldloc.1 [{i8,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      5) stfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [MethodInfo]
      5) ldtoken [Func<Arr<bool>,(Seq<i8>,Seq<i8>,i8),{i8,Seq<i8>},({i8,str}),(Seq<i8>,Seq<i8>,i8)>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.2
      5) newarr [obj]
      1) dup
      1) ldc.i4.1
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      1) dup
      1) ldc.i4.5
      5) newarr [bool]
      5) newobj (Seq<i8>,Seq<i8>,i8)()
      1) ldnull
      1) ldloc.0 [({i8,str})]
      5) callvirt Func<Arr<bool>,(Seq<i8>,Seq<i8>,i8),{i8,Seq<i8>},({i8,str}),(Seq<i8>,Seq<i8>,i8)>::Invoke(Arr<bool>, (Seq<i8>,Seq<i8>,i8), {i8,Seq<i8>}, ({i8,str})):(Seq<i8>,Seq<i8>,i8)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<(Seq<i8>,Seq<i8>,i8),{i8,Seq<i8>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [Func<(Seq<i8>,Seq<i8>,i8),i4,obj,(Seq<i8>,Seq<i8>,i8)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.4
      5) ldelem [BndModuleNode]
      1) ldloc.0 [({i8,str})]
      5) newobj RuntimeModule<{i8,Seq<i8>},(Seq<i8>,Seq<i8>,i8),({i8,str})>(Func<Arr<bool>,(Seq<i8>,Seq<i8>,i8),{i8,Seq<i8>},({i8,str}),(Seq<i8>,Seq<i8>,i8)>, (Seq<i8>,Seq<i8>,i8), Func<(Seq<i8>,Seq<i8>,i8),{i8,Seq<i8>}>, Func<(Seq<i8>,Seq<i8>,i8),i4,obj,(Seq<i8>,Seq<i8>,i8)>, BndModuleNode, ({i8,str}))
      1) ret
  Total Size: 180

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      2) ldc.i4.s [10]
      1) conv.i8
      5) call static RangeGen::Exec(i8):ICachingEnumerable<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<i8,RuntimeModule<{i8,Seq<i8>}>>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.2
      5) newarr [obj]
      1) dup
      1) ldc.i4.0
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Arr<obj>]
      5) stelem [Arr<obj>]
      1) dup
      1) ldc.i4.1
      1) ldloc.0 [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,RuntimeModule<{i8,Seq<i8>}>>):Seq<RuntimeModule<{i8,Seq<i8>}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<RuntimeModule<{i8,Seq<i8>}>>):Seq<RuntimeModule<{i8,Seq<i8>}>>
      1) ret
  Total Size: 78

Func sig: (<ctx>:x) to M{let Num:i8, var X:i8*}*
Sequence: Seq<RuntimeModule<{i8,Seq<i8>}>>
 0) module symbols:
      var X from Sequence: Seq<i8>
         def Sequence: Seq<i8>
      let Num: 0
 1) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         def Sequence: Seq<i8>
         0) 0
      let Num: 1
 2) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         def Sequence: Seq<i8>
         0) 0
         1) 1
      let Num: 2
 3) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
      let Num: 3
 4) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
      let Num: 4
 5) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
      let Num: 5
 6) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
      let Num: 6
 7) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
      let Num: 7
 8) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
         7) 7
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
         7) 7
      let Num: 8
 9) module symbols:
      var X from Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
         7) 7
         8) 8
         def Sequence: Seq<i8>
         0) 0
         1) 1
         2) 2
         3) 3
         4) 4
         5) 5
         6) 6
         7) 7
         8) 8
      let Num: 9
*** Ctx ping count: 0
###
> Range(10)->ForEach(as n,
    module {
        var X from T->Take(n);
        let Num := X->Count()
    })
Range(10)->ForEach(as n, module { var X from T->Take(n); let Num := X->Count() }) : M{let Num:i8, var X:{A:r8, B:s}*}*
BndKind:Call, Type:M{let Num:i8, var X:{A:r8, B:s}*}*, Bnd:(Call(∂.ForEach([map:1] Call(∂.Range(10:i8):i8*), module[ext[with:2] (Global(T),Scope(1),), items[with:3] ]{ var X from Call(∂.Take(GetSlot(Scope(2), 0), GetSlot(Scope(2), 1))) def GetSlot(Scope(3), 0) opt; let Num := Call(∂.Count(GetSlot(Scope(3), 1)):i8) }):M{let Num:i8, var X:{A:r8, B:s}*}*))
// (<ctx>, ∂.T:{A:r8, B:s}*) : M{let Num:i8, var X:{A:r8, B:s}*}*
set_module_items_ext(Arr<obj>, Arr<bool>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), {i8,Seq<{r8,str}>}, (Seq<{r8,str}>,i8)):(Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.0
      1) ldelem.u1
      5) brtrue [0]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      2) ldarg.s [(Seq<{r8,str}>,i8) (4)]
      5) ldfld (Seq<{r8,str}>,i8)::_F0:Seq<{r8,str}>
      2) ldarg.s [(Seq<{r8,str}>,i8) (4)]
      5) ldfld (Seq<{r8,str}>,i8)::_F1:i8
      5) call static TakeDropGen::ExecTakeNum(Seq<{r8,str}>, i8):Seq<{r8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{r8,str}>):Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:Seq<{r8,str}>
  Label [0]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.3
      1) ldelem.u1
      5) brfalse [1]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.3 [{i8,Seq<{r8,str}>}]
      5) ldfld {i8,Seq<{r8,str}>}::_F1:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
      5) br [2]
  Label [1]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.1
      1) ldelem.u1
      5) brtrue [2]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
  Label [2]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.2
      1) ldelem.u1
      5) brtrue [3]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.0
      5) call static CountGen::Exec(Seq<{r8,str}>, ExecCtx, i4):i8
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:i8
  Label [3]:
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ret
  Total Size: 118

make_module_record(Arr<obj>, (Seq<{r8,str}>,Seq<{r8,str}>,i8)):{i8,Seq<{r8,str}>}
      5) newobj {i8,Seq<{r8,str}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {i8,Seq<{r8,str}>}::_B0:u1
      1) stloc.0 [{i8,Seq<{r8,str}>}]
      1) ldloc.0 [{i8,Seq<{r8,str}>}]
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
      5) stfld {i8,Seq<{r8,str}>}::_F1:Seq<{r8,str}>
      1) ldloc.0 [{i8,Seq<{r8,str}>}]
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:i8
      5) stfld {i8,Seq<{r8,str}>}::_F0:i8
      1) ldloc.0 [{i8,Seq<{r8,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

set_module_value_item(Arr<obj>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), i4, obj):(Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.2 [i4]
     17) switch [0,1,0]
      5) br [0]
  Label [1]:
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.3 [obj]
      5) unbox.any [Seq<{r8,str}>]
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
  Label [0]:
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ret
  Total Size: 37

ForEach_1(Arr<obj>, i8):RuntimeModule<{i8,Seq<{r8,str}>}>
      5) newobj (Seq<{r8,str}>,i8)()
      1) stloc.0 [(Seq<{r8,str}>,i8)]
      1) ldloc.0 [(Seq<{r8,str}>,i8)]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [(Seq<{r8,str}>)]
      5) ldfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,i8)::_F0:Seq<{r8,str}>
      1) ldloc.0 [(Seq<{r8,str}>,i8)]
      1) ldarg.1 [i8]
      5) stfld (Seq<{r8,str}>,i8)::_F1:i8
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<Arr<bool>,(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>},(Seq<{r8,str}>,i8),(Seq<{r8,str}>,Seq<{r8,str}>,i8)>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.2
      5) newarr [obj]
      1) dup
      1) ldc.i4.1
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      1) dup
      1) ldc.i4.5
      5) newarr [bool]
      5) newobj (Seq<{r8,str}>,Seq<{r8,str}>,i8)()
      1) ldnull
      1) ldloc.0 [(Seq<{r8,str}>,i8)]
      5) callvirt Func<Arr<bool>,(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>},(Seq<{r8,str}>,i8),(Seq<{r8,str}>,Seq<{r8,str}>,i8)>::Invoke(Arr<bool>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), {i8,Seq<{r8,str}>}, (Seq<{r8,str}>,i8)):(Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),i4,obj,(Seq<{r8,str}>,Seq<{r8,str}>,i8)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [BndModuleNode]
      1) ldloc.0 [(Seq<{r8,str}>,i8)]
      5) newobj RuntimeModule<{i8,Seq<{r8,str}>},(Seq<{r8,str}>,Seq<{r8,str}>,i8),(Seq<{r8,str}>,i8)>(Func<Arr<bool>,(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>},(Seq<{r8,str}>,i8),(Seq<{r8,str}>,Seq<{r8,str}>,i8)>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>}>, Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),i4,obj,(Seq<{r8,str}>,Seq<{r8,str}>,i8)>, BndModuleNode, (Seq<{r8,str}>,i8))
      1) ret
  Total Size: 144

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{r8,str}>
      1) stloc.1 [Seq<{r8,str}>]
      5) newobj (Seq<{r8,str}>)()
      1) stloc.2 [(Seq<{r8,str}>)]
      1) ldloc.2 [(Seq<{r8,str}>)]
      1) ldloc.1 [Seq<{r8,str}>]
      5) stfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      2) ldc.i4.s [10]
      1) conv.i8
      5) call static RangeGen::Exec(i8):ICachingEnumerable<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<i8,RuntimeModule<{i8,Seq<{r8,str}>}>>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.3
      5) newarr [obj]
      1) dup
      1) ldc.i4.0
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Arr<obj>]
      5) stelem [Arr<obj>]
      1) dup
      1) ldc.i4.2
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) stelem [(Seq<{r8,str}>)]
      1) dup
      1) ldc.i4.1
      1) ldloc.0 [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,RuntimeModule<{i8,Seq<{r8,str}>}>>):Seq<RuntimeModule<{i8,Seq<{r8,str}>}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<RuntimeModule<{i8,Seq<{r8,str}>}>>):Seq<RuntimeModule<{i8,Seq<{r8,str}>}>>
      1) ret
  Total Size: 108

Func sig: (<ctx>:x, T:{A:r8, B:s}*) to M{let Num:i8, var X:{A:r8, B:s}*}*
Sequence: Seq<RuntimeModule<{i8,Seq<{r8,str}>}>>
 0) module symbols:
      var X from <null> def <null>
      let Num: 0
 1) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
      let Num: 1
 2) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
      let Num: 2
 3) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
      let Num: 3
 4) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
      let Num: 4
 5) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
      let Num: 5
 6) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
      let Num: 6
 7) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
      let Num: 7
 8) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
      let Num: 8
 9) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
         8) { A: 4, B: 8 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
         8) { A: 4, B: 8 }
      let Num: 9
*** Ctx ping count: 0
###
> Range(10)->{ A: it, B: ToText(it) }->ForEach(
    module {
        var X from T->Take(A);
        let Num := X->Count()
    })
Range(10)->{ A : it, B : ToText(it) }->ForEach(module { var X from T->Take(A); let Num := X->Count() }) : M{let Num:i8, var X:{A:r8, B:s}*}*
BndKind:Call, Type:M{let Num:i8, var X:{A:r8, B:s}*}*, Bnd:(Call(∂.ForEach([map:1] Call(∂.Range(10:i8):i8*), module[ext[with:2] (Global(T),{A:Scope(1), B:Call(∂.ToText(Scope(1)):s)},), items[with:3] ]{ var X from Call(∂.Take(GetSlot(Scope(2), 0), GetField(GetSlot(Scope(2), 1), A))) def GetSlot(Scope(3), 0) opt; let Num := Call(∂.Count(GetSlot(Scope(3), 1)):i8) }):M{let Num:i8, var X:{A:r8, B:s}*}*))
// (<ctx>, ∂.T:{A:r8, B:s}*) : M{let Num:i8, var X:{A:r8, B:s}*}*
set_module_items_ext(Arr<obj>, Arr<bool>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), {i8,Seq<{r8,str}>}, (Seq<{r8,str}>,{i8,str})):(Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.0
      1) ldelem.u1
      5) brtrue [0]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      2) ldarg.s [(Seq<{r8,str}>,{i8,str}) (4)]
      5) ldfld (Seq<{r8,str}>,{i8,str})::_F0:Seq<{r8,str}>
      2) ldarg.s [(Seq<{r8,str}>,{i8,str}) (4)]
      5) ldfld (Seq<{r8,str}>,{i8,str})::_F1:{i8,str}
      5) ldfld {i8,str}::_F0:i8
      5) call static TakeDropGen::ExecTakeNum(Seq<{r8,str}>, i8):Seq<{r8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{r8,str}>):Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:Seq<{r8,str}>
  Label [0]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.3
      1) ldelem.u1
      5) brfalse [1]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.3 [{i8,Seq<{r8,str}>}]
      5) ldfld {i8,Seq<{r8,str}>}::_F1:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
      5) br [2]
  Label [1]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.1
      1) ldelem.u1
      5) brtrue [2]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F0:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
  Label [2]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.2
      1) ldelem.u1
      5) brtrue [3]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.0
      5) call static CountGen::Exec(Seq<{r8,str}>, ExecCtx, i4):i8
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:i8
  Label [3]:
      1) ldarg.2 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ret
  Total Size: 123

make_module_record(Arr<obj>, (Seq<{r8,str}>,Seq<{r8,str}>,i8)):{i8,Seq<{r8,str}>}
      5) newobj {i8,Seq<{r8,str}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {i8,Seq<{r8,str}>}::_B0:u1
      1) stloc.0 [{i8,Seq<{r8,str}>}]
      1) ldloc.0 [{i8,Seq<{r8,str}>}]
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
      5) stfld {i8,Seq<{r8,str}>}::_F1:Seq<{r8,str}>
      1) ldloc.0 [{i8,Seq<{r8,str}>}]
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      5) ldfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F2:i8
      5) stfld {i8,Seq<{r8,str}>}::_F0:i8
      1) ldloc.0 [{i8,Seq<{r8,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

set_module_value_item(Arr<obj>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), i4, obj):(Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.2 [i4]
     17) switch [0,1,0]
      5) br [0]
  Label [1]:
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ldarg.3 [obj]
      5) unbox.any [Seq<{r8,str}>]
      5) stfld (Seq<{r8,str}>,Seq<{r8,str}>,i8)::_F1:Seq<{r8,str}>
  Label [0]:
      1) ldarg.1 [(Seq<{r8,str}>,Seq<{r8,str}>,i8)]
      1) ret
  Total Size: 37

ForEach_1(Arr<obj>, i8):RuntimeModule<{i8,Seq<{r8,str}>}>
      5) newobj (Seq<{r8,str}>,{i8,str})()
      1) stloc.0 [(Seq<{r8,str}>,{i8,str})]
      1) ldloc.0 [(Seq<{r8,str}>,{i8,str})]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [(Seq<{r8,str}>)]
      5) ldfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,{i8,str})::_F0:Seq<{r8,str}>
      1) ldloc.0 [(Seq<{r8,str}>,{i8,str})]
      5) newobj {i8,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,str}::_B0:u1
      1) stloc.1 [{i8,str}]
      1) ldloc.1 [{i8,str}]
      1) ldarg.1 [i8]
      5) stfld {i8,str}::_F0:i8
      1) ldloc.1 [{i8,str}]
      1) ldarg.1 [i8]
      1) stloc.2 [i8]
      2) ldloca.s [i8 (2)]
      5) call i8::ToString():str
      5) stfld {i8,str}::_F1:str
      1) ldloc.1 [{i8,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      5) stfld (Seq<{r8,str}>,{i8,str})::_F1:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [MethodInfo]
      5) ldtoken [Func<Arr<bool>,(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>},(Seq<{r8,str}>,{i8,str}),(Seq<{r8,str}>,Seq<{r8,str}>,i8)>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.2
      5) newarr [obj]
      1) dup
      1) ldc.i4.1
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      1) dup
      1) ldc.i4.5
      5) newarr [bool]
      5) newobj (Seq<{r8,str}>,Seq<{r8,str}>,i8)()
      1) ldnull
      1) ldloc.0 [(Seq<{r8,str}>,{i8,str})]
      5) callvirt Func<Arr<bool>,(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>},(Seq<{r8,str}>,{i8,str}),(Seq<{r8,str}>,Seq<{r8,str}>,i8)>::Invoke(Arr<bool>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), {i8,Seq<{r8,str}>}, (Seq<{r8,str}>,{i8,str})):(Seq<{r8,str}>,Seq<{r8,str}>,i8)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),i4,obj,(Seq<{r8,str}>,Seq<{r8,str}>,i8)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.4
      5) ldelem [BndModuleNode]
      1) ldloc.0 [(Seq<{r8,str}>,{i8,str})]
      5) newobj RuntimeModule<{i8,Seq<{r8,str}>},(Seq<{r8,str}>,Seq<{r8,str}>,i8),(Seq<{r8,str}>,{i8,str})>(Func<Arr<bool>,(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>},(Seq<{r8,str}>,{i8,str}),(Seq<{r8,str}>,Seq<{r8,str}>,i8)>, (Seq<{r8,str}>,Seq<{r8,str}>,i8), Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),{i8,Seq<{r8,str}>}>, Func<(Seq<{r8,str}>,Seq<{r8,str}>,i8),i4,obj,(Seq<{r8,str}>,Seq<{r8,str}>,i8)>, BndModuleNode, (Seq<{r8,str}>,{i8,str}))
      1) ret
  Total Size: 198

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{r8,str}>
      1) stloc.1 [Seq<{r8,str}>]
      5) newobj (Seq<{r8,str}>)()
      1) stloc.2 [(Seq<{r8,str}>)]
      1) ldloc.2 [(Seq<{r8,str}>)]
      1) ldloc.1 [Seq<{r8,str}>]
      5) stfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      2) ldc.i4.s [10]
      1) conv.i8
      5) call static RangeGen::Exec(i8):ICachingEnumerable<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<i8,RuntimeModule<{i8,Seq<{r8,str}>}>>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.3
      5) newarr [obj]
      1) dup
      1) ldc.i4.0
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Arr<obj>]
      5) stelem [Arr<obj>]
      1) dup
      1) ldc.i4.2
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) stelem [(Seq<{r8,str}>)]
      1) dup
      1) ldc.i4.1
      1) ldloc.0 [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,RuntimeModule<{i8,Seq<{r8,str}>}>>):Seq<RuntimeModule<{i8,Seq<{r8,str}>}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<RuntimeModule<{i8,Seq<{r8,str}>}>>):Seq<RuntimeModule<{i8,Seq<{r8,str}>}>>
      1) ret
  Total Size: 108

Func sig: (<ctx>:x, T:{A:r8, B:s}*) to M{let Num:i8, var X:{A:r8, B:s}*}*
Sequence: Seq<RuntimeModule<{i8,Seq<{r8,str}>}>>
 0) module symbols:
      var X from <null> def <null>
      let Num: 0
 1) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
      let Num: 1
 2) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
      let Num: 2
 3) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
      let Num: 3
 4) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
      let Num: 4
 5) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
      let Num: 5
 6) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
      let Num: 6
 7) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
      let Num: 7
 8) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
      let Num: 8
 9) module symbols:
      var X from Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
         8) { A: 4, B: 8 }
         def Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
         8) { A: 4, B: 8 }
      let Num: 9
*** Ctx ping count: 0
###
> With(
    M1 : module { var X in T; let Y := X.A },
    M2 : module { var X := R; let Y := X.A + 1 },
    (M1, M2, [M1, M2]))
With(M1 : module { var X in T; let Y := X.A }, M2 : module { var X def R; let Y := X.A + 1 }, (M1, M2, [M1, M2])) : (M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}*)
BndKind:Call, Type:(M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}*), Bnd:(Call(∂.With([with:3] module[ext[with:1] (Global(T),), items[with:2] ]{ var X in GetSlot(Scope(1), 0) def Call(∂.TakeOne(GetSlot(Scope(2), 0), [else] dflt<{A:r8, B:s}>)); let Y := GetField(GetSlot(Scope(2), 1), A) }, [with:6] module[ext[with:4] (Global(R),), items[with:5] ]{ var X def GetSlot(Scope(4), 0); let Y := Add(GetField(GetSlot(Scope(5), 0), A), 1:r8) }, (Scope(3), Scope(6), [Scope(3), Scope(6)]:M{var X:{A:r8, B:s}, let Y:r8}*):(M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}*)):(M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}*)))
// (∂.T:{A:r8, B:s}*, ∂.R:{A:r8, B:s}) : (M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}*)
set_module_items_ext(Arr<obj>, Arr<bool>, (Seq<{r8,str}>,{r8,str},r8), {{r8,str},r8}, (Seq<{r8,str}>)):(Seq<{r8,str}>,{r8,str},r8)
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.0
      1) ldelem.u1
      5) brtrue [0]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},r8)]
      2) ldarg.s [(Seq<{r8,str}>) (4)]
      5) ldfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,{r8,str},r8)::_F0:Seq<{r8,str}>
  Label [0]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.3
      1) ldelem.u1
      5) brfalse [1]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},r8)]
      1) ldarg.3 [{{r8,str},r8}]
      5) ldfld {{r8,str},r8}::_F0:{r8,str}
      5) stfld (Seq<{r8,str}>,{r8,str},r8)::_F1:{r8,str}
      5) br [2]
  Label [1]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.1
      1) ldelem.u1
      5) brtrue [2]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},r8)]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},r8)]
      5) ldfld (Seq<{r8,str}>,{r8,str},r8)::_F0:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [{r8,str}]
      5) call static TakeOneGen::Exec(Seq<{r8,str}>, {r8,str}):{r8,str}
      5) stfld (Seq<{r8,str}>,{r8,str},r8)::_F1:{r8,str}
  Label [2]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.2
      1) ldelem.u1
      5) brtrue [3]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},r8)]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},r8)]
      5) ldfld (Seq<{r8,str}>,{r8,str},r8)::_F1:{r8,str}
      5) ldfld {r8,str}::_F0:r8
      5) stfld (Seq<{r8,str}>,{r8,str},r8)::_F2:r8
  Label [3]:
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},r8)]
      1) ret
  Total Size: 105

make_module_record(Arr<obj>, (Seq<{r8,str}>,{r8,str},r8)):{{r8,str},r8}
      5) newobj {{r8,str},r8}()
      1) dup
      1) ldc.i4.2
      5) stfld {{r8,str},r8}::_B0:u1
      1) stloc.0 [{{r8,str},r8}]
      1) ldloc.0 [{{r8,str},r8}]
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str},r8)]
      5) ldfld (Seq<{r8,str}>,{r8,str},r8)::_F1:{r8,str}
      1) dup
      5) brfalse [0]
      5) stfld {{r8,str},r8}::_F0:{r8,str}
      1) ldloc.0 [{{r8,str},r8}]
      1) dup
      5) ldfld {{r8,str},r8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{r8,str},r8}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      1) ldloc.0 [{{r8,str},r8}]
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str},r8)]
      5) ldfld (Seq<{r8,str}>,{r8,str},r8)::_F2:r8
      5) stfld {{r8,str},r8}::_F1:r8
      1) ldloc.0 [{{r8,str},r8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 79

set_module_value_item(Arr<obj>, (Seq<{r8,str}>,{r8,str},r8), i4, obj):(Seq<{r8,str}>,{r8,str},r8)
      1) ldarg.2 [i4]
     17) switch [0,1,0]
      5) br [0]
  Label [1]:
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str},r8)]
      1) ldarg.3 [obj]
      5) unbox.any [{r8,str}]
      5) stfld (Seq<{r8,str}>,{r8,str},r8)::_F1:{r8,str}
  Label [0]:
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str},r8)]
      1) ret
  Total Size: 37

set_module_items_ext(Arr<obj>, Arr<bool>, ({r8,str},r8), {{r8,str},r8}, ({r8,str})):({r8,str},r8)
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.2
      1) ldelem.u1
      5) brfalse [0]
      1) ldarg.2 [({r8,str},r8)]
      1) ldarg.3 [{{r8,str},r8}]
      5) ldfld {{r8,str},r8}::_F0:{r8,str}
      5) stfld ({r8,str},r8)::_F0:{r8,str}
      5) br [1]
  Label [0]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.0
      1) ldelem.u1
      5) brtrue [1]
      1) ldarg.2 [({r8,str},r8)]
      2) ldarg.s [({r8,str}) (4)]
      5) ldfld ({r8,str})::_F0:{r8,str}
      5) stfld ({r8,str},r8)::_F0:{r8,str}
  Label [1]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.1
      1) ldelem.u1
      5) brtrue [2]
      1) ldarg.2 [({r8,str},r8)]
      1) ldarg.2 [({r8,str},r8)]
      5) ldfld ({r8,str},r8)::_F0:{r8,str}
      5) ldfld {r8,str}::_F0:r8
      9) ldc.r8 [1]
      1) add
      5) stfld ({r8,str},r8)::_F1:r8
  Label [2]:
      1) ldarg.2 [({r8,str},r8)]
      1) ret
  Total Size: 83

make_module_record(Arr<obj>, ({r8,str},r8)):{{r8,str},r8}
      5) newobj {{r8,str},r8}()
      1) dup
      1) ldc.i4.2
      5) stfld {{r8,str},r8}::_B0:u1
      1) stloc.0 [{{r8,str},r8}]
      1) ldloc.0 [{{r8,str},r8}]
      1) ldarg.1 [({r8,str},r8)]
      5) ldfld ({r8,str},r8)::_F0:{r8,str}
      1) dup
      5) brfalse [0]
      5) stfld {{r8,str},r8}::_F0:{r8,str}
      1) ldloc.0 [{{r8,str},r8}]
      1) dup
      5) ldfld {{r8,str},r8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{r8,str},r8}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      1) ldloc.0 [{{r8,str},r8}]
      1) ldarg.1 [({r8,str},r8)]
      5) ldfld ({r8,str},r8)::_F1:r8
      5) stfld {{r8,str},r8}::_F1:r8
      1) ldloc.0 [{{r8,str},r8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 79

set_module_value_item(Arr<obj>, ({r8,str},r8), i4, obj):({r8,str},r8)
      1) ldarg.2 [i4]
     13) switch [1,0]
      5) br [0]
  Label [1]:
      1) ldarg.1 [({r8,str},r8)]
      1) ldarg.3 [obj]
      5) unbox.any [{r8,str}]
      5) stfld ({r8,str},r8)::_F0:{r8,str}
  Label [0]:
      1) ldarg.1 [({r8,str},r8)]
      1) ret
  Total Size: 33

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{r8,str}>
      1) stloc.0 [Seq<{r8,str}>]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{r8,str}
      1) stloc.1 [{r8,str}]
      5) newobj (Seq<{r8,str}>)()
      1) stloc.2 [(Seq<{r8,str}>)]
      1) ldloc.2 [(Seq<{r8,str}>)]
      1) ldloc.0 [Seq<{r8,str}>]
      5) stfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<Arr<bool>,(Seq<{r8,str}>,{r8,str},r8),{{r8,str},r8},(Seq<{r8,str}>),(Seq<{r8,str}>,{r8,str},r8)>]
      1) dup
      1) ldc.i4.5
      5) newarr [bool]
      5) newobj (Seq<{r8,str}>,{r8,str},r8)()
      1) ldnull
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) callvirt Func<Arr<bool>,(Seq<{r8,str}>,{r8,str},r8),{{r8,str},r8},(Seq<{r8,str}>),(Seq<{r8,str}>,{r8,str},r8)>::Invoke(Arr<bool>, (Seq<{r8,str}>,{r8,str},r8), {{r8,str},r8}, (Seq<{r8,str}>)):(Seq<{r8,str}>,{r8,str},r8)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<(Seq<{r8,str}>,{r8,str},r8),{{r8,str},r8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<(Seq<{r8,str}>,{r8,str},r8),i4,obj,(Seq<{r8,str}>,{r8,str},r8)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [BndModuleNode]
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) newobj RuntimeModule<{{r8,str},r8},(Seq<{r8,str}>,{r8,str},r8),(Seq<{r8,str}>)>(Func<Arr<bool>,(Seq<{r8,str}>,{r8,str},r8),{{r8,str},r8},(Seq<{r8,str}>),(Seq<{r8,str}>,{r8,str},r8)>, (Seq<{r8,str}>,{r8,str},r8), Func<(Seq<{r8,str}>,{r8,str},r8),{{r8,str},r8}>, Func<(Seq<{r8,str}>,{r8,str},r8),i4,obj,(Seq<{r8,str}>,{r8,str},r8)>, BndModuleNode, (Seq<{r8,str}>))
      1) stloc.3 [RuntimeModule<{{r8,str},r8}>]
      5) newobj ({r8,str})()
      2) stloc.s [({r8,str}) (4)]
      2) ldloc.s [({r8,str}) (4)]
      1) ldloc.1 [{r8,str}]
      5) stfld ({r8,str})::_F0:{r8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.4
      5) ldelem [Func<Arr<bool>,({r8,str},r8),{{r8,str},r8},({r8,str}),({r8,str},r8)>]
      1) dup
      1) ldc.i4.4
      5) newarr [bool]
      5) newobj ({r8,str},r8)()
      1) ldnull
      2) ldloc.s [({r8,str}) (4)]
      5) callvirt Func<Arr<bool>,({r8,str},r8),{{r8,str},r8},({r8,str}),({r8,str},r8)>::Invoke(Arr<bool>, ({r8,str},r8), {{r8,str},r8}, ({r8,str})):({r8,str},r8)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.5
      5) ldelem [Func<({r8,str},r8),{{r8,str},r8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.6
      5) ldelem [Func<({r8,str},r8),i4,obj,({r8,str},r8)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.7
      5) ldelem [BndModuleNode]
      2) ldloc.s [({r8,str}) (4)]
      5) newobj RuntimeModule<{{r8,str},r8},({r8,str},r8),({r8,str})>(Func<Arr<bool>,({r8,str},r8),{{r8,str},r8},({r8,str}),({r8,str},r8)>, ({r8,str},r8), Func<({r8,str},r8),{{r8,str},r8}>, Func<({r8,str},r8),i4,obj,({r8,str},r8)>, BndModuleNode, ({r8,str}))
      2) stloc.s [RuntimeModule<{{r8,str},r8}> (5)]
      5) newobj (RuntimeModule<{{r8,str},r8}>,RuntimeModule<{{r8,str},r8}>,Seq<RuntimeModule<{{r8,str},r8}>>)()
      1) dup
      1) ldloc.3 [RuntimeModule<{{r8,str},r8}>]
      5) stfld (RuntimeModule<{{r8,str},r8}>,RuntimeModule<{{r8,str},r8}>,Seq<RuntimeModule<{{r8,str},r8}>>)::_F0:RuntimeModule<{{r8,str},r8}>
      1) dup
      2) ldloc.s [RuntimeModule<{{r8,str},r8}> (5)]
      5) stfld (RuntimeModule<{{r8,str},r8}>,RuntimeModule<{{r8,str},r8}>,Seq<RuntimeModule<{{r8,str},r8}>>)::_F1:RuntimeModule<{{r8,str},r8}>
      1) dup
      1) ldc.i4.2
      5) newarr [RuntimeModule<{{r8,str},r8}>]
      1) dup
      1) ldc.i4.0
      1) ldloc.3 [RuntimeModule<{{r8,str},r8}>]
      5) stelem [RuntimeModule<{{r8,str},r8}>]
      1) dup
      1) ldc.i4.1
      2) ldloc.s [RuntimeModule<{{r8,str},r8}> (5)]
      5) stelem [RuntimeModule<{{r8,str},r8}>]
      5) stfld (RuntimeModule<{{r8,str},r8}>,RuntimeModule<{{r8,str},r8}>,Seq<RuntimeModule<{{r8,str},r8}>>)::_F2:Seq<RuntimeModule<{{r8,str},r8}>>
      1) ret
  Total Size: 207

Func sig: (T:{A:r8, B:s}*, R:{A:r8, B:s}) to (M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}, M{var X:{A:r8, B:s}, let Y:r8}*)
Type: (RuntimeModule<{{r8,str},r8}>,RuntimeModule<{{r8,str},r8}>,Seq<RuntimeModule<{{r8,str},r8}>>), Value: (module symbols:
      var X in Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
         8) { A: 4, B: 8 }
         9) { A: 4.5, B: 9 }
         def { A: 0, B: 0 }
      let Y: 0
  , module symbols:
      var X def { A: 3.5, B: RB }
      let Y: 4.5
  , Sequence: Seq<RuntimeModule<{{r8,str},r8}>>
     0) module symbols:
          var X in Sequence: Seq<{r8,str}>
             0) { A: 0, B: 0 }
             1) { A: 0.5, B: 1 }
             2) { A: 1, B: 2 }
             3) { A: 1.5, B: 3 }
             4) { A: 2, B: 4 }
             5) { A: 2.5, B: 5 }
             6) { A: 3, B: 6 }
             7) { A: 3.5, B: 7 }
             8) { A: 4, B: 8 }
             9) { A: 4.5, B: 9 }
             def { A: 0, B: 0 }
          let Y: 0
     1) module symbols:
          var X def { A: 3.5, B: RB }
          let Y: 4.5
)
###
> With(
    M : module { var X in T },
    RR : { X: R },
    (M, RR, [M, RR]))
With(M : module { var X in T }, RR : { X : R }, (M, RR, [M, RR])) : (M{var X:{A:r8, B:s}}, {X:{A:r8, B:s}}, {X:{A:r8, B:s}}*)
BndKind:Call, Type:(M{var X:{A:r8, B:s}}, {X:{A:r8, B:s}}, {X:{A:r8, B:s}}*), Bnd:(Call(∂.With([with:3] module[ext[with:1] (Global(T),), items[with:2] ]{ var X in GetSlot(Scope(1), 0) def Call(∂.TakeOne(GetSlot(Scope(2), 0), [else] dflt<{A:r8, B:s}>)) }, [with:4] {X:Global(R)}, (Scope(3), Scope(4), [ModToRec(Scope(3)), Scope(4)]:{X:{A:r8, B:s}}*):(M{var X:{A:r8, B:s}}, {X:{A:r8, B:s}}, {X:{A:r8, B:s}}*)):(M{var X:{A:r8, B:s}}, {X:{A:r8, B:s}}, {X:{A:r8, B:s}}*)))
// (∂.T:{A:r8, B:s}*, ∂.R:{A:r8, B:s}) : (M{var X:{A:r8, B:s}}, {X:{A:r8, B:s}}, {X:{A:r8, B:s}}*)
set_module_items_ext(Arr<obj>, Arr<bool>, (Seq<{r8,str}>,{r8,str}), {{r8,str}}, (Seq<{r8,str}>)):(Seq<{r8,str}>,{r8,str})
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.0
      1) ldelem.u1
      5) brtrue [0]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str})]
      2) ldarg.s [(Seq<{r8,str}>) (4)]
      5) ldfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,{r8,str})::_F0:Seq<{r8,str}>
  Label [0]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.2
      1) ldelem.u1
      5) brfalse [1]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str})]
      1) ldarg.3 [{{r8,str}}]
      5) ldfld {{r8,str}}::_F0:{r8,str}
      5) stfld (Seq<{r8,str}>,{r8,str})::_F1:{r8,str}
      5) br [2]
  Label [1]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.1
      1) ldelem.u1
      5) brtrue [2]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str})]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str})]
      5) ldfld (Seq<{r8,str}>,{r8,str})::_F0:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [{r8,str}]
      5) call static TakeOneGen::Exec(Seq<{r8,str}>, {r8,str}):{r8,str}
      5) stfld (Seq<{r8,str}>,{r8,str})::_F1:{r8,str}
  Label [2]:
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str})]
      1) ret
  Total Size: 80

make_module_record(Arr<obj>, (Seq<{r8,str}>,{r8,str})):{{r8,str}}
      5) newobj {{r8,str}}()
      1) stloc.0 [{{r8,str}}]
      1) ldloc.0 [{{r8,str}}]
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str})]
      5) ldfld (Seq<{r8,str}>,{r8,str})::_F1:{r8,str}
      1) dup
      5) brfalse [0]
      5) stfld {{r8,str}}::_F0:{r8,str}
      1) ldloc.0 [{{r8,str}}]
      1) dup
      5) ldfld {{r8,str}}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{r8,str}}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      1) ldloc.0 [{{r8,str}}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 60

set_module_value_item(Arr<obj>, (Seq<{r8,str}>,{r8,str}), i4, obj):(Seq<{r8,str}>,{r8,str})
      1) ldarg.2 [i4]
     13) switch [0,1]
      5) br [0]
  Label [1]:
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str})]
      1) ldarg.3 [obj]
      5) unbox.any [{r8,str}]
      5) stfld (Seq<{r8,str}>,{r8,str})::_F1:{r8,str}
  Label [0]:
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str})]
      1) ret
  Total Size: 33

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{r8,str}>
      1) stloc.0 [Seq<{r8,str}>]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{r8,str}
      1) stloc.1 [{r8,str}]
      5) newobj (Seq<{r8,str}>)()
      1) stloc.2 [(Seq<{r8,str}>)]
      1) ldloc.2 [(Seq<{r8,str}>)]
      1) ldloc.0 [Seq<{r8,str}>]
      5) stfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<Arr<bool>,(Seq<{r8,str}>,{r8,str}),{{r8,str}},(Seq<{r8,str}>),(Seq<{r8,str}>,{r8,str})>]
      1) dup
      1) ldc.i4.3
      5) newarr [bool]
      5) newobj (Seq<{r8,str}>,{r8,str})()
      1) ldnull
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) callvirt Func<Arr<bool>,(Seq<{r8,str}>,{r8,str}),{{r8,str}},(Seq<{r8,str}>),(Seq<{r8,str}>,{r8,str})>::Invoke(Arr<bool>, (Seq<{r8,str}>,{r8,str}), {{r8,str}}, (Seq<{r8,str}>)):(Seq<{r8,str}>,{r8,str})
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<(Seq<{r8,str}>,{r8,str}),{{r8,str}}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<(Seq<{r8,str}>,{r8,str}),i4,obj,(Seq<{r8,str}>,{r8,str})>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [BndModuleNode]
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) newobj RuntimeModule<{{r8,str}},(Seq<{r8,str}>,{r8,str}),(Seq<{r8,str}>)>(Func<Arr<bool>,(Seq<{r8,str}>,{r8,str}),{{r8,str}},(Seq<{r8,str}>),(Seq<{r8,str}>,{r8,str})>, (Seq<{r8,str}>,{r8,str}), Func<(Seq<{r8,str}>,{r8,str}),{{r8,str}}>, Func<(Seq<{r8,str}>,{r8,str}),i4,obj,(Seq<{r8,str}>,{r8,str})>, BndModuleNode, (Seq<{r8,str}>))
      1) stloc.3 [RuntimeModule<{{r8,str}}>]
      5) newobj {{r8,str}}()
      2) stloc.s [{{r8,str}} (4)]
      2) ldloc.s [{{r8,str}} (4)]
      1) ldloc.1 [{r8,str}]
      1) dup
      5) brfalse [0]
      5) stfld {{r8,str}}::_F0:{r8,str}
      2) ldloc.s [{{r8,str}} (4)]
      1) dup
      5) ldfld {{r8,str}}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{r8,str}}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      2) ldloc.s [{{r8,str}} (4)]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.4
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      2) stloc.s [{{r8,str}} (4)]
      5) newobj (RuntimeModule<{{r8,str}}>,{{r8,str}},Seq<{{r8,str}}>)()
      1) dup
      1) ldloc.3 [RuntimeModule<{{r8,str}}>]
      5) stfld (RuntimeModule<{{r8,str}}>,{{r8,str}},Seq<{{r8,str}}>)::_F0:RuntimeModule<{{r8,str}}>
      1) dup
      2) ldloc.s [{{r8,str}} (4)]
      5) stfld (RuntimeModule<{{r8,str}}>,{{r8,str}},Seq<{{r8,str}}>)::_F1:{{r8,str}}
      1) dup
      1) ldc.i4.2
      5) newarr [{{r8,str}}]
      1) dup
      1) ldc.i4.0
      1) ldloc.3 [RuntimeModule<{{r8,str}}>]
      5) callvirt RuntimeModule<{{r8,str}}>::GetRecord():{{r8,str}}
      5) stelem [{{r8,str}}]
      1) dup
      1) ldc.i4.1
      2) ldloc.s [{{r8,str}} (4)]
      5) stelem [{{r8,str}}]
      5) stfld (RuntimeModule<{{r8,str}}>,{{r8,str}},Seq<{{r8,str}}>)::_F2:Seq<{{r8,str}}>
      1) ret
  Total Size: 200

Func sig: (T:{A:r8, B:s}*, R:{A:r8, B:s}) to (M{var X:{A:r8, B:s}}, {X:{A:r8, B:s}}, {X:{A:r8, B:s}}*)
Type: (RuntimeModule<{{r8,str}}>,{{r8,str}},Seq<{{r8,str}}>), Value: (module symbols:
      var X in Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
         8) { A: 4, B: 8 }
         9) { A: 4.5, B: 9 }
         def { A: 0, B: 0 }
  , { X: { A: 3.5, B: RB } }, 
  Sequence: Seq<{{r8,str}}>
     0) { X: { A: 0, B: 0 } }
     1) { X: { A: 3.5, B: RB } }
)
###
> With(
    M : module { var X in T; var Z from 0 to 100 },
    RR : { X: R, Y: 3.5 },
    (M, RR, [M, RR]))
With(M : module { var X in T; var Z from 0 to 100 }, RR : { X : R, Y : 3.5 }, (M, RR, [M, RR])) : (M{var X:{A:r8, B:s}, var Z:i8}, {X:{A:r8, B:s}, Y:r8}, {X:{A:r8, B:s}, Y:r8?, Z:i8?}*)
BndKind:Call, Type:(M{var X:{A:r8, B:s}, var Z:i8}, {X:{A:r8, B:s}, Y:r8}, {X:{A:r8, B:s}, Y:r8?, Z:i8?}*), Bnd:(Call(∂.With([with:3] module[ext[with:1] (Global(T),), items[with:2] ]{ var X in GetSlot(Scope(1), 0) def Call(∂.TakeOne(GetSlot(Scope(2), 0), [else] dflt<{A:r8, B:s}>)); var Z from 0:i8 to 100:i8 def GetSlot(Scope(2), 2) }, [with:4] {X:Global(R), Y:3.5:r8}, [with:5] ModToRec(Scope(3)), (Scope(3), Scope(4), [{X:GetField(Scope(5), X), Y:null:r8?, Z:Opt<i8?>(GetField(Scope(5), Z))}, {X:GetField(Scope(4), X), Y:Opt<r8?>(GetField(Scope(4), Y)), Z:null:i8?}]:{X:{A:r8, B:s}, Y:r8?, Z:i8?}*):(M{var X:{A:r8, B:s}, var Z:i8}, {X:{A:r8, B:s}, Y:r8}, {X:{A:r8, B:s}, Y:r8?, Z:i8?}*)):(M{var X:{A:r8, B:s}, var Z:i8}, {X:{A:r8, B:s}, Y:r8}, {X:{A:r8, B:s}, Y:r8?, Z:i8?}*)))
// (∂.T:{A:r8, B:s}*, ∂.R:{A:r8, B:s}) : (M{var X:{A:r8, B:s}, var Z:i8}, {X:{A:r8, B:s}, Y:r8}, {X:{A:r8, B:s}, Y:r8?, Z:i8?}*)
set_module_items_ext(Arr<obj>, Arr<bool>, (Seq<{r8,str}>,{r8,str},i8,i8,i8), {{r8,str},i8}, (Seq<{r8,str}>)):(Seq<{r8,str}>,{r8,str},i8,i8,i8)
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.0
      1) ldelem.u1
      5) brtrue [0]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      2) ldarg.s [(Seq<{r8,str}>) (4)]
      5) ldfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      5) stfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F0:Seq<{r8,str}>
  Label [0]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.5
      1) ldelem.u1
      5) brfalse [1]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      1) ldarg.3 [{{r8,str},i8}]
      5) ldfld {{r8,str},i8}::_F0:{r8,str}
      5) stfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F1:{r8,str}
      5) br [2]
  Label [1]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.1
      1) ldelem.u1
      5) brtrue [2]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      5) ldfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F0:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [{r8,str}]
      5) call static TakeOneGen::Exec(Seq<{r8,str}>, {r8,str}):{r8,str}
      5) stfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F1:{r8,str}
  Label [2]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.2
      1) ldelem.u1
      5) brtrue [3]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      1) ldc.i4.0
      1) conv.i8
      5) stfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F2:i8
  Label [3]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.3
      1) ldelem.u1
      5) brtrue [4]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      2) ldc.i4.s [100]
      1) conv.i8
      5) stfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F3:i8
  Label [4]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.6
      1) ldelem.u1
      5) brfalse [5]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      1) ldarg.3 [{{r8,str},i8}]
      5) ldfld {{r8,str},i8}::_F1:i8
      5) stfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F4:i8
      5) br [6]
  Label [5]:
      1) ldarg.1 [Arr<bool>]
      1) ldc.i4.4
      1) ldelem.u1
      5) brtrue [6]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      5) ldfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F2:i8
      5) stfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F4:i8
  Label [6]:
      1) ldarg.2 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      1) ret
  Total Size: 158

make_module_record(Arr<obj>, (Seq<{r8,str}>,{r8,str},i8,i8,i8)):{{r8,str},i8}
      5) newobj {{r8,str},i8}()
      1) dup
      1) ldc.i4.2
      5) stfld {{r8,str},i8}::_B0:u1
      1) stloc.0 [{{r8,str},i8}]
      1) ldloc.0 [{{r8,str},i8}]
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      5) ldfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F1:{r8,str}
      1) dup
      5) brfalse [0]
      5) stfld {{r8,str},i8}::_F0:{r8,str}
      1) ldloc.0 [{{r8,str},i8}]
      1) dup
      5) ldfld {{r8,str},i8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{r8,str},i8}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      1) ldloc.0 [{{r8,str},i8}]
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      5) ldfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F4:i8
      5) stfld {{r8,str},i8}::_F1:i8
      1) ldloc.0 [{{r8,str},i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 79

set_module_value_item(Arr<obj>, (Seq<{r8,str}>,{r8,str},i8,i8,i8), i4, obj):(Seq<{r8,str}>,{r8,str},i8,i8,i8)
      1) ldarg.2 [i4]
     25) switch [0,1,0,0,2]
      5) br [0]
  Label [1]:
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      1) ldarg.3 [obj]
      5) unbox.any [{r8,str}]
      5) stfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F1:{r8,str}
      5) br [0]
  Label [2]:
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      1) ldarg.3 [obj]
      5) unbox.any [i8]
      5) stfld (Seq<{r8,str}>,{r8,str},i8,i8,i8)::_F4:i8
  Label [0]:
      1) ldarg.1 [(Seq<{r8,str}>,{r8,str},i8,i8,i8)]
      1) ret
  Total Size: 62

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{r8,str}>
      1) stloc.0 [Seq<{r8,str}>]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{r8,str}
      1) stloc.1 [{r8,str}]
      5) newobj (Seq<{r8,str}>)()
      1) stloc.2 [(Seq<{r8,str}>)]
      1) ldloc.2 [(Seq<{r8,str}>)]
      1) ldloc.0 [Seq<{r8,str}>]
      5) stfld (Seq<{r8,str}>)::_F0:Seq<{r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<Arr<bool>,(Seq<{r8,str}>,{r8,str},i8,i8,i8),{{r8,str},i8},(Seq<{r8,str}>),(Seq<{r8,str}>,{r8,str},i8,i8,i8)>]
      1) dup
      1) ldc.i4.7
      5) newarr [bool]
      5) newobj (Seq<{r8,str}>,{r8,str},i8,i8,i8)()
      1) ldnull
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) callvirt Func<Arr<bool>,(Seq<{r8,str}>,{r8,str},i8,i8,i8),{{r8,str},i8},(Seq<{r8,str}>),(Seq<{r8,str}>,{r8,str},i8,i8,i8)>::Invoke(Arr<bool>, (Seq<{r8,str}>,{r8,str},i8,i8,i8), {{r8,str},i8}, (Seq<{r8,str}>)):(Seq<{r8,str}>,{r8,str},i8,i8,i8)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<(Seq<{r8,str}>,{r8,str},i8,i8,i8),{{r8,str},i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<(Seq<{r8,str}>,{r8,str},i8,i8,i8),i4,obj,(Seq<{r8,str}>,{r8,str},i8,i8,i8)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [BndModuleNode]
      1) ldloc.2 [(Seq<{r8,str}>)]
      5) newobj RuntimeModule<{{r8,str},i8},(Seq<{r8,str}>,{r8,str},i8,i8,i8),(Seq<{r8,str}>)>(Func<Arr<bool>,(Seq<{r8,str}>,{r8,str},i8,i8,i8),{{r8,str},i8},(Seq<{r8,str}>),(Seq<{r8,str}>,{r8,str},i8,i8,i8)>, (Seq<{r8,str}>,{r8,str},i8,i8,i8), Func<(Seq<{r8,str}>,{r8,str},i8,i8,i8),{{r8,str},i8}>, Func<(Seq<{r8,str}>,{r8,str},i8,i8,i8),i4,obj,(Seq<{r8,str}>,{r8,str},i8,i8,i8)>, BndModuleNode, (Seq<{r8,str}>))
      1) stloc.3 [RuntimeModule<{{r8,str},i8}>]
      5) newobj {{r8,str},r8}()
      1) dup
      1) ldc.i4.2
      5) stfld {{r8,str},r8}::_B0:u1
      2) stloc.s [{{r8,str},r8} (4)]
      2) ldloc.s [{{r8,str},r8} (4)]
      1) ldloc.1 [{r8,str}]
      1) dup
      5) brfalse [0]
      5) stfld {{r8,str},r8}::_F0:{r8,str}
      2) ldloc.s [{{r8,str},r8} (4)]
      1) dup
      5) ldfld {{r8,str},r8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{r8,str},r8}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      2) ldloc.s [{{r8,str},r8} (4)]
      9) ldc.r8 [3.5]
      5) stfld {{r8,str},r8}::_F1:r8
      2) ldloc.s [{{r8,str},r8} (4)]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.4
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      2) stloc.s [{{r8,str},r8} (4)]
      1) ldloc.3 [RuntimeModule<{{r8,str},i8}>]
      5) callvirt RuntimeModule<{{r8,str},i8}>::GetRecord():{{r8,str},i8}
      2) stloc.s [{{r8,str},i8} (5)]
      5) newobj (RuntimeModule<{{r8,str},i8}>,{{r8,str},r8},Seq<{{r8,str},r8,i8}>)()
      1) dup
      1) ldloc.3 [RuntimeModule<{{r8,str},i8}>]
      5) stfld (RuntimeModule<{{r8,str},i8}>,{{r8,str},r8},Seq<{{r8,str},r8,i8}>)::_F0:RuntimeModule<{{r8,str},i8}>
      1) dup
      2) ldloc.s [{{r8,str},r8} (4)]
      5) stfld (RuntimeModule<{{r8,str},i8}>,{{r8,str},r8},Seq<{{r8,str},r8,i8}>)::_F1:{{r8,str},r8}
      1) dup
      1) ldc.i4.2
      5) newarr [{{r8,str},r8,i8}]
      1) dup
      1) ldc.i4.0
      5) newobj {{r8,str},r8,i8}()
      2) stloc.s [{{r8,str},r8,i8} (6)]
      2) ldloc.s [{{r8,str},r8,i8} (6)]
      2) ldloc.s [{{r8,str},i8} (5)]
      5) ldfld {{r8,str},i8}::_F0:{r8,str}
      1) dup
      5) brfalse [2]
      5) stfld {{r8,str},r8,i8}::_F0:{r8,str}
      2) ldloc.s [{{r8,str},r8,i8} (6)]
      1) dup
      5) ldfld {{r8,str},r8,i8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{r8,str},r8,i8}::_B0:u1
      5) br [3]
  Label [2]:
      1) pop
      1) pop
  Label [3]:
      2) ldloc.s [{{r8,str},r8,i8} (6)]
      2) ldloc.s [{{r8,str},i8} (5)]
      5) ldfld {{r8,str},i8}::_F1:i8
      5) stfld {{r8,str},r8,i8}::_F2:i8
      2) ldloc.s [{{r8,str},r8,i8} (6)]
      1) dup
      5) ldfld {{r8,str},r8,i8}::_B0:u1
      1) ldc.i4.4
      1) or
      5) stfld {{r8,str},r8,i8}::_B0:u1
      2) ldloc.s [{{r8,str},r8,i8} (6)]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.5
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      5) stelem [{{r8,str},r8,i8}]
      1) dup
      1) ldc.i4.1
      5) newobj {{r8,str},r8,i8}()
      2) stloc.s [{{r8,str},r8,i8} (6)]
      2) ldloc.s [{{r8,str},r8,i8} (6)]
      2) ldloc.s [{{r8,str},r8} (4)]
      5) ldfld {{r8,str},r8}::_F0:{r8,str}
      1) dup
      5) brfalse [4]
      5) stfld {{r8,str},r8,i8}::_F0:{r8,str}
      2) ldloc.s [{{r8,str},r8,i8} (6)]
      1) dup
      5) ldfld {{r8,str},r8,i8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{r8,str},r8,i8}::_B0:u1
      5) br [5]
  Label [4]:
      1) pop
      1) pop
  Label [5]:
      2) ldloc.s [{{r8,str},r8,i8} (6)]
      2) ldloc.s [{{r8,str},r8} (4)]
      5) ldfld {{r8,str},r8}::_F1:r8
      5) stfld {{r8,str},r8,i8}::_F1:r8
      2) ldloc.s [{{r8,str},r8,i8} (6)]
      1) dup
      5) ldfld {{r8,str},r8,i8}::_B0:u1
      1) ldc.i4.2
      1) or
      5) stfld {{r8,str},r8,i8}::_B0:u1
      2) ldloc.s [{{r8,str},r8,i8} (6)]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.5
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      5) stelem [{{r8,str},r8,i8}]
      5) stfld (RuntimeModule<{{r8,str},i8}>,{{r8,str},r8},Seq<{{r8,str},r8,i8}>)::_F2:Seq<{{r8,str},r8,i8}>
      1) ret
  Total Size: 409

Func sig: (T:{A:r8, B:s}*, R:{A:r8, B:s}) to (M{var X:{A:r8, B:s}, var Z:i8}, {X:{A:r8, B:s}, Y:r8}, {X:{A:r8, B:s}, Y:r8?, Z:i8?}*)
Type: (RuntimeModule<{{r8,str},i8}>,{{r8,str},r8},Seq<{{r8,str},r8,i8}>), Value: (module symbols:
      var X in Sequence: Seq<{r8,str}>
         0) { A: 0, B: 0 }
         1) { A: 0.5, B: 1 }
         2) { A: 1, B: 2 }
         3) { A: 1.5, B: 3 }
         4) { A: 2, B: 4 }
         5) { A: 2.5, B: 5 }
         6) { A: 3, B: 6 }
         7) { A: 3.5, B: 7 }
         8) { A: 4, B: 8 }
         9) { A: 4.5, B: 9 }
         def { A: 0, B: 0 }
      var Z from 0 to 100 def 0
  , { X: { A: 3.5, B: RB }, Y: 3.5 }, 
  Sequence: Seq<{{r8,str},r8,i8}>
     0) { X: { A: 0, B: 0 }, Y: <null>, Z: 0 }
     1) { X: { A: 3.5, B: RB }, Y: 3.5, Z: <null> }
)
###
